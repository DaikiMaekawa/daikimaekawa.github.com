<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>ゼロから始めるロボットプログラミング入門講座</title>
        <description>ゼロから始めるロボットプログラミング入門講座 - Daiki Maekawa</description>
        <link>http://DaikiMaekawa.github.io</link>
        <link>http://DaikiMaekawa.github.io</link>
        <lastBuildDate>2013-12-02T18:01:56+09:00</lastBuildDate>
        <pubDate>2013-12-02T18:01:56+09:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>XBeeを用いた無線通信</title>
                <description>&lt;hr&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;開発環境&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;基盤　　　　: SPPBoard(dsPIC30F3014使用)
コンパイラ　: C30
XBee        : XB24-Z7PIT-004
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;XBeeの通信方式はシリアル通信なのでdsPICのUARTに直結することができます。&lt;/p&gt;

&lt;p&gt;そこで、今回はXBeeによるdsPIC/PC間通信を題材にUARTを用いてシリアル通信を実装する方法について解説したいと思います。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;dsPIC - XBee(A) &amp;lt;--&amp;gt; XBee(B) - PC
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;XBeeは&lt;a href=&quot;http://akizukidenshi.com/catalog/g/gM-06195/&quot; title=&quot;XB24-Z7PIT-004&quot;&gt;XB24-Z7PIT-004&lt;/a&gt;(PCBアンテナタイプ)を使用します。&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id=&quot;toc_2&quot;&gt;UARTとは&lt;/h2&gt;

&lt;p&gt;単位時間あたり1bitずつ送られてくるシリアルデータをその都度シフトして適当なパラレルデータに変換する回路のことです。&lt;/p&gt;

&lt;h2 id=&quot;toc_3&quot;&gt;回路の基礎知識&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;RX: 受信
TX: 送信
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;toc_4&quot;&gt;dsPIC側のXBee&lt;/h3&gt;

&lt;p&gt;UART2の端子を使用します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/UART_pin.jpg&quot; alt=&quot;UART_pin&quot;&gt;&lt;/p&gt;

&lt;h3 id=&quot;toc_5&quot;&gt;PC側のXBee&lt;/h3&gt;

&lt;p&gt;PCからXBeeへの接続方法はUSBで接続するだけで済むようにしたいと思います。&lt;/p&gt;

&lt;p&gt;そのために今回はFT232RL_MODULEという変換モジュールを使用します。&lt;/p&gt;

&lt;p&gt;これはUSBの信号をXBeeに接続可能なTLLレベルに変換してくれるものです。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;FT232RL_MODULE  &amp;lt;--&amp;gt;  XBee
1  TXD          &amp;lt;--&amp;gt;  3  DIN/-CONFIG
5  RXD          &amp;lt;--&amp;gt;  2  DOUT
24 GND          &amp;lt;--&amp;gt;  10 GND
19 3V3          &amp;lt;--&amp;gt;  1  VCC
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h2 id=&quot;toc_6&quot;&gt;XBeeの設定&lt;/h2&gt;

&lt;h3 id=&quot;toc_7&quot;&gt;PC側のXBee&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;ボーレート  115200bps
FunctionSet ZIGBEECOORDINATOR AT
PANID       500
DH          13A200
DL          406E8886
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;toc_8&quot;&gt;dsPIC側のXBee&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;ボーレート  115200bps
FunctionSet ZIGBEEROUTER AT
PANID       500
DH          13A200
DL          40625D41
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h2 id=&quot;toc_9&quot;&gt;サンプルプログラム&lt;/h2&gt;

&lt;p&gt;C30コンパイラのバグでUARTで使用するピンはこちら側で定義する必要があります。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;#define UART_RX_TX 0xFBE7
#define UART_ALTRX_ALTTX 0xFFE7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(注)dsPIC30F3014はuart.hに上の定義がありません。&lt;/p&gt;

&lt;h3 id=&quot;toc_10&quot;&gt;送信完了待ち関数&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;void WaitSendString(const short UartChannel){
    switch(UartChannel){
        case UART1:
            while(BusyUART1());
            break;
        case UART2:
            while(BusyUART2());
            break;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;BusyUARTx()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;送信中なら1、送信完了なら0を返す&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;toc_11&quot;&gt;データ送信関数&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;void SendString(const short UartChannel, unsigned int *string){
    switch(UartChannel){
        case UART1:
            putsUART1(string);
            break;
        case UART2:
            putsUART2(string);
            break;
    }
    WaitSendString(UartChannel);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;toc_12&quot;&gt;受信完了待ち関数&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;void WaitGetString(const short UartChannel){
    switch(UartChannel){
        case UART1:
            while(!DataRdyUART1());
            break;
        case UART2:
            while(!DataRdyUART2());
            break;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;DataRdyUARTx()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;受信中なら0、受信完了なら1を返す&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;toc_13&quot;&gt;コマンド受信関数&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;char *GetCommand(const short UartChannel){
    unsigned char moji;
    int count = 0;
    static char string[MAX_UARTWORD];

    WaitGetString(UartChannel);

    switch(UartChannel){
        case UART1:
            moji = ReadUART1();
            break;
        case UART2:
            moji = ReadUART2();
            break;
    }

    while((moji != &amp;#39;\r&amp;#39;) &amp;amp;&amp;amp; (count &amp;lt; MAX_UARTWORD)){
        string[count] = moji;
        count++;
        WaitGetString(UartChannel);
        switch(UartChannel){
            case UART1:
                moji = ReadUART1();
                break;
            case UART2:
                moji = ReadUART2();
                break;
        }
    }

    string[count] = 0x00;
    return string;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ReadUARTx()&lt;/strong&gt;
1文字の受信関数&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;toc_14&quot;&gt;UART初期化関数&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;void UartInitFunc(void){
    unsigned int config1 = UART_EN &amp;amp; UART_IDLE_CON &amp;amp; UART_ALTRX_ALTTX &amp;amp; 
        UART_NO_PAR_8BIT &amp;amp; UART_1STOPBIT &amp;amp; UART_DIS_WAKE &amp;amp; UART_DIS_LOOPBACK &amp;amp; UART_DIS_ABAUD;

    unsigned int config2 = UART_INT_TX_BUF_EMPTY &amp;amp; UART_TX_PIN_NORMAL &amp;amp; UART_TX_ENABLE &amp;amp; 
        UART_INT_RX_CHAR &amp;amp; UART_ADR_DETECT_DIS &amp;amp; UART_RX_OVERRUN_CLEAR;

    OpenUART1(config1, config2, 10);
    OpenUART2(config1, config2, 10); //115kbps

    /*受信割り込み禁止、送信割り込み禁止*/
    ConfigIntUART1(UART_RX_INT_DIS &amp;amp; UART_TX_INT_DIS);
    ConfigIntUART2(UART_RX_INT_DIS &amp;amp; UART_TX_INT_DIS);

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;OpenUARTx(unsigned int config1, unsigned int config2, unsigned int ubrg)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ubrg(UxBRG) = FCY / (16 * BaudRate) - 1&lt;/p&gt;

&lt;p&gt;FCYとはFOSCを1/2倍したものです。&lt;/p&gt;

&lt;p&gt;FOSCは実際の命令周波数なので、クロック生成部分で出力される周波数の1/2となります。(PICは2つのクロックで1個の命令が実行されるため)&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;システムクロック80MHzで115kbpsのボーレートを得たい場合
UxBRG = 20000 / (16 * 115) - 1
UxBRG = 0.987
ubrgに10を渡せば良いことがわかります。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;UART_EN or UART_DIS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;UARTモジュールを有効/無効&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;UART_IDLE_CON or UART_IDLE_STOP&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;アイドル中動作継続/停止&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;UART_ALTRX_ALTTX or UART_RX_TX&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;代替/通常ピンを使用&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;UART_NO_PAR_9BIT or UART_ODD_PAR_8BIT or UART_EVEN_PAR_8BIT or UART_NO_PAR_8BIT&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;9ビットデータ + パリティなし&lt;/p&gt;

&lt;p&gt;8ビットデータ + 奇数パリティ&lt;/p&gt;

&lt;p&gt;8ビットデータ + 偶数パリティ&lt;/p&gt;

&lt;p&gt;8ビットデータ + パリティなし&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;念のためパリティビットについての復習

パリティビットとはデータが正常に送られたかを検査するために使用されるビットです。
偶数パリティ、奇数パリティの2種類が存在し、これは送信するデータの1の数が偶数または奇数になるようにパリティビットで調整されます。

(例)
1000 0010 &amp;#39;A&amp;#39;というASCIIコードを送信する

偶数パリティ
1000 00100

奇数パリティ
1000 00101
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;UART_2STOPBITS or UART_1STOPBIT&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ストップビット長を2ビット/1ビットに設定&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;UART_DIS_WAKE&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SLEEP中にスタートビットが来た時のウェイクアップを有効化&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;UART_EN_LOOPBACK or UART_DIS_LOOPBACK&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ループバックモード(送信したデータを自分に戻してテストする機能)を有効/無効&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;UART_EN_ABAUD or UART_DIS_ABAUD&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ボーレートの自動検出を有効/無効&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;UART_INT_TX_BUF_EMPTY or UART_INT_TX&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;送信バッファが完全に空になったら/空きがあれば割り込む&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;UART_TX_PIN_NORMAL or UART_TX_PIN_LOW&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通常動作/ブレーク&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;ブレーク信号とは中断信号のことです。
通信を強制的に中断して初期状態に戻したりする際に用いられます。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;UART_TX_ENABLE or UART_TX_DISABLE&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;送信有効/無効&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;UART_INT_RX_CHAR&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;文字を受信する度に割り込む&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;UART_ADR_DETECT_DIS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;アドレス文字を検出しない&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;UART_RX_OVERRUN_CLEAR&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;オーバーランした場合はビットクリアする&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;以上でUARTを用いたシリアル通信のサンプルプログラムの完成です。&lt;/p&gt;
</description>
                <link>http://DaikiMaekawa.github.io/sppboard/2013/11/24/UART</link>
                <guid>http://DaikiMaekawa.github.io/sppboard/2013/11/24/UART</guid>
                <pubDate>2013-11-24T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>VisualStudio2012でQtを使うための手順</title>
                <description>&lt;p&gt;QtのVisualStudio2012向けバイナリはまだ存在してしないのでソースをビルドする必要があります。&lt;/p&gt;

&lt;p&gt;Qtのソースをダウンロード、展開してC:\Qt4.8.5に移動し、名前を変更します&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/12113400/compiling-qt-4-8-x-for-visual-studio-2012/14928303#14928303&quot;&gt;HashSet.hをダウンロード&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ディレクトリのsrc\3rdparty\webkit\Source\JavaScriptCore\wtfにあるHashSet.hと置き換えます。&lt;/p&gt;

&lt;p&gt;「VS2012 x86 Native Tools コマンドプロンプト」を開き以下のコマンドを実行します。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;cd C:\Qt4.8.5
set QT_HOME=C:\Qt4.8.5
set PATH=%QT_HOME%\bin;%PATH%
configure -mp -opensource -nomake demos -nomake examples -platform win32-msvc2012
nmake
nmake clean
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(注)nmakeには数時間かかる&lt;/p&gt;

&lt;p&gt;以上でVisualStudio2012でQtを使うための解説を終わります。&lt;/p&gt;
</description>
                <link>http://DaikiMaekawa.github.io/qt/2013/10/02/QtBuild</link>
                <guid>http://DaikiMaekawa.github.io/qt/2013/10/02/QtBuild</guid>
                <pubDate>2013-10-02T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>ジャイロセンサの制御方法(続き)</title>
                <description>&lt;hr&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;開発環境&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;基盤　　　　　　: SPPBoard(dsPIC30F3014使用)  
コンパイラ　　　: C30  
ジャイロセンサ　: IMU3000  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://daikimaekawa.github.io/sppboard/2013/08/30/GyroSensor/&quot; title=&quot;I2Cの基礎&quot;&gt;以前&lt;/a&gt;、ジャイロセンサ(IMU3000)をdsPIC上で制御するための基礎知識について解説しました。&lt;/p&gt;

&lt;p&gt;今回はIMU3000の通信仕様について軽く触れた後にdsPIC上で制御するサンプルプログラムを紹介します。&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id=&quot;toc_2&quot;&gt;IMU3000とは?&lt;/h2&gt;

&lt;p&gt;3.3V駆動でx, y, z方向の3軸仕様でI2Cインタフェースをサポートしたジャイロセンサです。&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id=&quot;toc_3&quot;&gt;IMU3000の通信方法&lt;/h2&gt;

&lt;p&gt;それではIMU3000の仕様書から必要な情報を読み取りましょう。&lt;/p&gt;

&lt;h3 id=&quot;toc_4&quot;&gt;データ送信方式&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/IMU3000_send.jpg&quot; alt=&quot;send&quot;&gt;&lt;/p&gt;

&lt;p&gt;記号に関しては以下を参照&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/IMU3000_terms.jpg&quot; alt=&quot;terms&quot;&gt;&lt;/p&gt;

&lt;h3 id=&quot;toc_5&quot;&gt;データ受信方式&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/IMU3000_read.jpg&quot; alt=&quot;read&quot;&gt;&lt;/p&gt;

&lt;h3 id=&quot;toc_6&quot;&gt;レジスタ解説&lt;/h3&gt;

&lt;p&gt;ジャイロの値を取得する際にアクセスする必要があるレジスタについて解説します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/IMU3000_terms02.jpg&quot; alt=&quot;terms&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/IMU3000_register.jpg&quot; alt=&quot;register&quot;&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Register 60&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;FIFO Dataレジスタにはレジスタ18で有効にされたデータが16ビットで格納されています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/IMU3000_register60.jpg&quot; alt=&quot;register60&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/IMU3000_register60_terms.jpg&quot; alt=&quot;register60&quot;&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Register 18&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;FIFOレジスタに格納するデータを選択する&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/IMU3000_register18.jpg&quot; alt=&quot;register18&quot;&gt;&lt;/p&gt;

&lt;p&gt;IMU3000のFIFOは最低でも1ワード読み出しできるものがないといけないのでそれを保証するのでFIFO_FOOTERです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Register 22&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ジャイロのフルスケールレンジとサンプルレートを設定します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/IMU3000_register22.jpg&quot; alt=&quot;register22&quot;&gt;&lt;/p&gt;

&lt;p&gt;フィルターとサンプルレートの設定する&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/IMU3000_register22_spec.jpg&quot; alt=&quot;register22&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/IMU3000_register22_02.jpg&quot; alt=&quot;register22&quot;&gt;&lt;/p&gt;

&lt;p&gt;フルスケールレンジの設定する&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/IMU3000_register22_spec_02.jpg&quot; alt=&quot;register22&quot;&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Register 21&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;サンプルレートを設定する&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/IMU3000_register21.jpg&quot; alt=&quot;register21&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/IMU3000_register21_02.jpg&quot; alt=&quot;register21&quot;&gt;&lt;/p&gt;

&lt;p&gt;(注) 8ビットなので当然、SMPLRT_DIVは0 ~ 255の範囲で設定すること&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Register 61&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用したい機能はこのレジスタでリセットする&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/IMU3000_register61.jpg&quot; alt=&quot;register61&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/IMU3000_register61_param.jpg&quot; alt=&quot;register61&quot;&gt;&lt;/p&gt;

&lt;p&gt;FIFO_ENとFIFO_RSTとGYRO_RSTは最低限設定する必要があります。&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id=&quot;toc_7&quot;&gt;IMU3000の制御関数を作ろう&lt;/h2&gt;

&lt;h3 id=&quot;toc_8&quot;&gt;初期化関数&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;I2C I2CInitFunc(void){
    I2C i2c;
    static short first = TRUE;

    if(first){
        I2CBRG = 399;
        I2CCON = 0b1001001001111101;
        IDLE_I2C;
        I2CADD = 0x09;
        first = FALSE;
    }

    i2c.close = _CloseI2C;
    i2c.write = WriteI2C;
    i2c.read  = ReadI2C;
    i2c.SendDataToIMU = SendDataToIMU;
    i2c.ReadDataFromIMU = ReadDataFromIMU;

    return i2c;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/images/I2C_register_map.jpg&quot; alt=&quot;i2c_register_map&quot;&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CBRG = 399&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通信速度を設定
40MHz動作時に100kHzで通信&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CCON = 0b1001001001111101&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I2Cの初期設定&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CADD = 0x09&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;スレーブとしてのアドレスを設定&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;toc_9&quot;&gt;データ送信用関数&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;static void SendDataI2C(I2CData data){

    I2CTRN = data;
    if(!I2CSTATbits.IWCOL){
        while(I2CSTATbits.TRSTAT);
        IDLE_I2C;
    }

    while(I2CSTATbits.TBF);
    while(I2CSTATbits.ACKSTAT);
    IDLE_I2C;

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CTRN = data&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;データ送信&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;if(!I2CSTATbits.IWCOL)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;書き込み衝突なしの場合&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;while(I2CSTATbits.TRSTAT)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;送信終了待ち&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;while(I2CSTATbits.TBF)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I2CTRNが空になるまで待つ&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;while(I2CSTATbits.ACKSTAT)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;アクノリッジが返って来るまで待つ&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;toc_10&quot;&gt;アドレス送信関数&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;static void SendAddressI2C(I2CData address, char AddressType){
    address = address &amp;lt;&amp;lt; 1;
    if(AddressType == SEND){
        address &amp;amp;= 0b11111110;
    }else{
        address |= 0b00000001;
    }
    SendDataI2C(address);

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;スレーブへ送信する場合は最下位ビットを0に
スレーブから受信する場合は最下位ビットを1にする。&lt;/p&gt;

&lt;h3 id=&quot;toc_11&quot;&gt;IMU3000への送信関数&lt;/h3&gt;

&lt;p&gt;この関数は仕様書に書かれている以下の規則に従ったものです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/IMU3000_send.jpg&quot; alt=&quot;send&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;static void SendDataToIMU(I2CData I2CAddress, I2CData RegisterAddress, I2CData data){

    I2CCONbits.SEN = 1;
    IDLE_I2C;

    SendAddressI2C(I2CAddress, SEND);
    SendDataI2C(RegisterAddress);
    SendDataI2C(data);

    I2CCONbits.PEN = 1;
    IDLE_I2C;

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CCONbits.SEN = 1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;スタートコンディション発行&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;SendAddressI2C(I2CAddress, SEND)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;IMUアドレス+送信要求&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;SendDataI2C(RegisterAddress)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;レジスタアドレスを送信&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;SendDataI2C(data)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;レジスタへの書き込み&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CCONbits.PEN = 1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ストップコンディション発行&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;toc_12&quot;&gt;汎用送信関数&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;static void WriteI2C(I2CData address, I2CData data){

    I2CCONbits.SEN = 1;
    IDLE_I2C;

    SendAddressI2C(address, SEND);
    SendDataI2C(data);

    I2CCONbits.PEN = 1;
    IDEL_I2C;

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;toc_13&quot;&gt;IMU3000からの受信関数&lt;/h3&gt;

&lt;p&gt;この関数は仕様書に書かれている以下の規則に従ったものです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/IMU3000_read.jpg&quot; alt=&quot;read&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;static I2CData ReadDataFromIMU(I2CData I2CAddress, I2CData RegisterAddress){

    I2CData buffer;

    I2CCONbits.SEN = 1;
    IDLE_I2C;

    SendAddressI2C(I2CAddress, SEND);
    SendDataI2C(RegisterAddress);

    I2CCONbits.SEN = 1;
    IDLE_I2c;

    SendAddressI2C(I2CAddress, READ);

    I2CCONbits.RCEN = 1;
    while(I2CCONbits.RCEN);
    I2CSTATbits.I2COV = 0;
    buffer = I2CRCV;
    IDLE_I2C;

    I2CCONbits.ACKDT = 1;
    I2CCONbits.ACKEN = 1;
    IDLE_I2C;

    I2CCONbits.PEN = 1;
    IDLE_I2C;

    return buffer;

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;SendAddressI2C(I2CAddress, SEND)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;アドレス+送信要求&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;SendDataI2C(RegisterAddress)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;レジスタアドレス送信&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;SendAddressI2C(I2CAddress, READ)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;アドレス+受信要求&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CCONbits.RCEN = 1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;受信モードを有効化&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;while(I2CCONbits.RCEN)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有効化待ち&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CSTATbits.I2COV = 0&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;オーバーフローなしにセット&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;buffer = I2CRCV&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;受信データを読み出し&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CCONbits.ACKDT = 1&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;I2CCONbits.ACKEN = 1&lt;/strong&gt;  &lt;/p&gt;

&lt;p&gt;NACKを出力&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;toc_14&quot;&gt;汎用受信関数&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;static I2CData ReadI2C(I2CData address){

    unsigned char received_data;

    I2CCONbits.SEN = 1;
    IDLE_I2C;

    SendAddressI2C(address, READ);

    I2CCONbits.RCEN = 1;
    while(I2CCONbits.RCEN);
    I2CSTATbits.I2COV = 0;
    received_data = I2CRCV;
    IDLE_I2C;

    I2CCONbits.ACKDT = 1;
    I2CCONbits.ACKEN = 1;
    IDLE_I2C;

    I2CCONbits.PEN = 1;
    IDLE_I2C;

    return received_data;

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h2 id=&quot;toc_15&quot;&gt;IMU3000の制御関数を使ってみよう&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;int main(void){

    int buffer[8];
    int GyroX;
    int i;
    TRISA = 0x800;
    TRISB = 0x1C7;
    TRISC = 0x6000;
    TRISD = 0x200;
    TRISF = 0x0000;

    I2C i2c = I2CInitFunc();
    Lcd lcd = LcdInitFunc();

    i2c.SendDataToIMU(GYRO, 0x12, 0x71);
    i2c.SendDataToIMU(GYRO, 0x16, 0x09);
    i2c.SendDataToIMU(GYRO, 0x15, 0x07);
    i2c.SendDataToIMU(GYRO, 0x3D, 0x43);

    while(1){
        for(i=0; i &amp;lt; 8; i++) buffer[i] = (int)i2c.ReadDataFromIMU(GYRO, 0x3C);
        GyroX = buffer[0] &amp;lt;&amp;lt; 8 | buffer[1];

        lcd.NumPuts(GyroX);
        wait_msec(1000);
        lcd.clear();
        wait_msec(1000);
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;GYRO&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;IMU3000のアドレス&lt;/p&gt;

&lt;p&gt;0x68であらかじめ定義している&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;i2c.SendDataToIMU(GYRO, 0x12, 0x71)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;FIFO Enable (GyroX + GyroY + GyroZ + FIFO_FOOTER)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;i2c.SendDataToIMU(GYRO, 0x16, 0x09)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;DLPF, Full scale(500 deg/sec, LowPass-&amp;gt;188Hz, ADサンプルレート1kHz)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;i2c.SendDataToIMU(GYRO, 0x15, 0x07)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SampleRate(125Hz)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;i2c.SendDataToIMU(GYRO, 0x3D, 0x43)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;User Control (FIFO_EN = 1, FIFO_RST = 1, GYRO_RST = 1)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;for(i=0; i &amp;lt; 8; i++) buffer[i] = (int)i2c.ReadDataFromIMU(GYRO, 0x3C)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;FIFOレジスタからX, Y, Z, FIFO_FOOTERを取得&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;lcd.NumPuts(GyroX)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;X軸の値をLCDに表示&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;lcd.clear()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;LCDの表示をクリア&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;以上でジャイロセンサから取得したX軸の値をLCDに表示するサンプログラムの完成です。&lt;/p&gt;
</description>
                <link>http://DaikiMaekawa.github.io/sppboard/2013/09/06/GyroSensor02</link>
                <guid>http://DaikiMaekawa.github.io/sppboard/2013/09/06/GyroSensor02</guid>
                <pubDate>2013-09-06T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>ジャイロセンサの制御方法</title>
                <description>&lt;hr&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;開発環境&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;基盤　　　　　　: SPPBoard(dsPIC30F3014使用)  
コンパイラ　　　: C30  
ジャイロセンサ　: IMU3000  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;SPPBoard上でジャイロセンサ(IMU3000)を制御するプログラムを作成してみましょう。&lt;/p&gt;

&lt;p&gt;IMU3000はI2Cインタフェースをサポートしているので、今回はI2C通信に関する基礎を解説したいと思います。&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id=&quot;toc_2&quot;&gt;I2Cの基礎知識&lt;/h2&gt;

&lt;h3 id=&quot;toc_3&quot;&gt;I2Cとは&lt;/h3&gt;

&lt;p&gt;I2CはInter Integrated Circuit(集積回路間通信)の略です。&lt;/p&gt;

&lt;p&gt;I2Cはデータ線が送受信兼用で1本しかありません。&lt;/p&gt;

&lt;p&gt;つまりI2Cの構成はデータ線+クロック線の2本となります。&lt;/p&gt;

&lt;h3 id=&quot;toc_4&quot;&gt;I2Cはシリアル通信&lt;/h3&gt;

&lt;p&gt;I2Cは同期式シリアル通信なので基準となるクロックパルスに合わせてデータ線へ信号を出力することになります。&lt;/p&gt;

&lt;h3 id=&quot;toc_5&quot;&gt;マスタとスレーブ&lt;/h3&gt;

&lt;p&gt;クロックパルスを送信する側のことを「マスタ」、送られてきたクロックパルスに従って動作する側のことを「スレーブ」といいます。&lt;/p&gt;

&lt;p&gt;また、I2Cではクロックを送信するのは必ずマスタ側です。&lt;/p&gt;

&lt;h3 id=&quot;toc_6&quot;&gt;回路構成&lt;/h3&gt;

&lt;p&gt;I2Cのピンにはプルアップ抵抗が必要です。&lt;/p&gt;

&lt;p&gt;これは様々なデバイスに対応するためにオープン・ドレイン端子となってためです。&lt;/p&gt;

&lt;p&gt;I2Cのハードウェアは非常に単純です。&lt;/p&gt;

&lt;p&gt;しかし、それを補うためプログラムは少し複雑になります。&lt;/p&gt;

&lt;h3 id=&quot;toc_7&quot;&gt;通信のタイミング&lt;/h3&gt;

&lt;p&gt;I2Cのデータバス(SDA)はプルアップされているので初期状態で1です。&lt;/p&gt;

&lt;p&gt;クロック(SCL)も同様です。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;SCL: 1と0を交互に出力
SDA: SCLが1の時状態を変化させてはいけない
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(注) 通信の開始と終了の時だけは例外です&lt;/p&gt;

&lt;p&gt;SCLが1の時&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;SDA 1 -&amp;gt; 0 : スタート・コンディション(通信開始命令)
SDA 0 -&amp;gt; 1 : ストップ・コンディション(通信停止命令)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これらの命令を発行できるのはマスタだけです。&lt;/p&gt;

&lt;p&gt;データの送受信をする際、スレーブ側から応答が返ってきたことを確認しながらデータをやりとりする仕組みになっています。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;1. データの送受信の単位は8ビット
 -&amp;gt; 送信終了時にマスタはSDAを1に戻して受信待機状態

2. スレーブが送信側になる
 -&amp;gt; 1ビットだけ0を送信(アクノリッジ信号)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;マスタは8ビット送信後アクノリッジが来るまで待っていることで、常に正しく通信することができます。&lt;/p&gt;

&lt;p&gt;例としてマスタが受信でスレーブが送信の場合を考えます。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;1. マスタが受信要求を出します
2. スレーブからアクノリッジが返ってきます
3. スレーが続けてデータを送信します
4. マスタはこれを受信し、8ビット区切りでアクノリッジを返します
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(注) スレーブ側では8ビット送信後、マスタがアクノリッジを返すまで待機します。&lt;/p&gt;

&lt;h3 id=&quot;toc_8&quot;&gt;アドレス送信の方式&lt;/h3&gt;

&lt;p&gt;I2Cでは一つのデータバスへ複数のデバイスを繋ぐことができます。&lt;/p&gt;

&lt;p&gt;通信するスレーブはアドレスにより固定します。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;1. スタートコンディション発行
2.「スレーブアドレス+要求」を送信

要求はそのデバイスへ(から)の送信(受信)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;アドレス指定には10ビットアドレスモードと7ビットアドレスモードの二つです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;10ビットアドレスモード&lt;/strong&gt;  &lt;/p&gt;

&lt;p&gt;8ビットを2回に分けて送信する&lt;/p&gt;

&lt;p&gt;最初に送信する8ビットは上位5ビットは「1 1 1 1 0」
残り3ビットはアドレスの上位2ビット+送受信指定&lt;/p&gt;

&lt;p&gt;次に送信する8ビットはすべてアドレスデータ&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;7ビットアドレスモード&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;7ビットのアドレス+送受信指定&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;送受信指定ビット
 | -&amp;gt; 送信なら0
 | -&amp;gt; 受信なら1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h2 id=&quot;toc_9&quot;&gt;実際にプログラムにするにはどうするか&lt;/h2&gt;

&lt;p&gt;基本的にはC30コンパイラのI2C関連の関数を呼び出すだけでできます。&lt;/p&gt;

&lt;p&gt;コンパイラのバグでそのままではライブラリがリンクされていませんので手動で行う必要があります。&lt;/p&gt;

&lt;p&gt;その方法に関しては&lt;a href=&quot;http://www2.ocn.ne.jp/%7Emhage/PIC_Trap/I2C.html&quot; title=&quot;I2C&quot;&gt;このサイト&lt;/a&gt;を参照してください。&lt;/p&gt;

&lt;p&gt;勉強のためここではあえてライブラリを使用せずにレジスタを直接操作することによりI2C通信を実現しジャイロセンサを制御してみましょう。&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id=&quot;toc_10&quot;&gt;仕様書からレジスタマップを読み解こう&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://ww1.microchip.com/downloads/en/devicedoc/70138c.pdf#search=%27dsPIC30F3014%27&quot; title=&quot;dsPIC30F3014&quot;&gt;dsPIC30F3014の仕様書を入手&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;toc_11&quot;&gt;I2CCONレジスタ&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/register_map.jpg&quot; alt=&quot;register_map&quot;&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CCON&lt;15&gt; I2CEN&lt;/strong&gt;  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   [0]: I2Cモジュールを無効
   [1]: I2Cモジュールを有効
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I2Cモジュールを有効にした際マスタ、スレーブ両方有効になります。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CCON&lt;13&gt; I2CSIDL&lt;/strong&gt;  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   [0]: アイドル時動作継続
   [1]: アイドル時動作中止
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CCON&lt;12&gt; SCLREL&lt;/strong&gt;&lt;br&gt;
スレーブとして動作時&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   [0]: SCLをLowに保持する
   [1]: SCLを自由に動作させる
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CCON&lt;11&gt; IPMIEN&lt;/strong&gt;  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   [0]: Intelligent peripheral management interface(IPMI)を無効
   [1]: IPMIを有効
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CCON&lt;10&gt; A10M&lt;/strong&gt;  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   [0]: I2CADDは7ビットアドレスモード
   [1]: 10ビットアドレスモード
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CCON&lt;9&gt; DISSLW&lt;/strong&gt;  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   [0]: スルーレート制御を有効
   [1]: スルーレート制御を無効
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CCON&lt;8&gt; SMEN&lt;/strong&gt;  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   [0]: SMBus入力のしきい値を無効
   [1]: I/Oピンを使用可能にしSMBusの使用に準拠したしきい値が設定される。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CCON&lt;7&gt; GCEN&lt;/strong&gt;&lt;br&gt;
スレーブとして動作時&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   [0]: 一斉呼び出しアドレスを無効化
   [1]: 一斉呼び出しアドレスがI2CRSRで受信された場合に割り込みを有効化
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CCON&lt;6&gt; STREN&lt;/strong&gt;&lt;br&gt;
スレーブとして動作時&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   [0]: クロック延長のソフトと受信を無効化
   [1]: クロック延長のソフトと受信を有効化
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CCON&lt;5&gt; ACKDT&lt;/strong&gt;&lt;br&gt;
マスタとして動作時&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   [0]: 応答としてNACKを送信
   [1]: 応答としてACKを送信
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CCON&lt;4&gt; ACKEN&lt;/strong&gt;&lt;br&gt;
マスタとして動作時&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   [0]: 応答シーケンスを使わない
   [1]: SDAとSCLピン上でシーケンスの確認応答を開始し、ADKDTデータビットを送信
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CCON&lt;3&gt; RCEN&lt;/strong&gt;&lt;br&gt;
マスタとして動作時&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   [0]: 受信シーケンスを有効化しない
   [1]: I2Cの受信モードを有効化
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CCON&lt;2&gt; PEN&lt;/strong&gt;&lt;br&gt;
マスタとして動作時&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   [0]: ストップコンディションを無効
   [1]: SDAとSCLを使ってストップコンディションを送信
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CCON&lt;1&gt; RSEN&lt;/strong&gt;&lt;br&gt;
マスタとして動作時&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   [0]: Repeated START条件を有効化しない
   [1]: SDAピン及びSCLピンでRepeated START条件を開始
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CCON&lt;0&gt; SEN&lt;/strong&gt;&lt;br&gt;
マスタとして動作時&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   [0]: スタートコンディションを送信しない
   [1]: スタートコンディションを送信する
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;toc_12&quot;&gt;I2CSTATレジスタ&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CSTAT&lt;15&gt; ACKSTAT&lt;/strong&gt;&lt;br&gt;
マスタとして動作時&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   [0]: アクノリッジをスレーブから受信
   [1]: アクノリッジをスレーブから受信待ち
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CSTAT&lt;14&gt; TRSTAT&lt;/strong&gt;&lt;br&gt;
マスタとして動作時&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   [0]: 送信終了
   [1]: (8ビット+ACK)の送信中
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CSTAT&lt;10&gt; BCL&lt;/strong&gt;  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   [0]: バス衝突なし
   [1]: バス衝突を検出
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CSTAT&lt;9&gt; GCSTAT&lt;/strong&gt;&lt;br&gt;
ジェネラルコールアドレスについて&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   [0]: 受信していない
   [1]: 受信した
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CSTAT&lt;8&gt; ADD10&lt;/strong&gt;  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   [0]: 10ビットのアドレス不一致
   [1]: 10ビットのアドレス一致
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CSTAT&lt;7&gt; IWCOL&lt;/strong&gt;&lt;br&gt;
       [0]: 書き込み衝突なし
       [1]: I2Cがビジー状態(I2CTRNに書き込みましょう)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CSTAT&lt;6&gt; I2COV&lt;/strong&gt;  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   [0]: オーバーフローなし
   [1]: I2CRCVレジスタが前のバイトを保持している間にバイトを受信した
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CSTAT&lt;5&gt; D_A&lt;/strong&gt;&lt;br&gt;
スレーブとして動作時、最後に受信したバイトは&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   [0]: デバイスアドレス
   [1]: データ
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CSTAT&lt;4&gt; P&lt;/strong&gt;  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   [0]: ストップビットが最後に検出されなかった
   [1]: ストップビットが最後に検出されていた
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CSTAT&lt;3&gt; S&lt;/strong&gt;&lt;br&gt;
最後にスタートコンディションが&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   [0]: 検出されなかった
   [1]: 検出された(もしかしたら反復スタートコンディション)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CSTAT&lt;2&gt; R_W&lt;/strong&gt;&lt;br&gt;
スレーブとして動作時&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   [0]: データ書き込み中
   [1]: データ読み込み中
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CSTAT&lt;1&gt; RBF&lt;/strong&gt;  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   [0]: 受信未完了(I2CRCVが空)
   [1]: 受信完了(I2CRCVがいっぱい)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I2CSTAT&lt;0&gt; TBF&lt;/strong&gt;  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;   [0]: 送信完了(I2CTRNが空)
   [1]: 送信中  (I2CTRNがいっぱい)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;検証した結果、TBFとTRSTATは同時に0になります&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;toc_13&quot;&gt;I2CBRG&lt;/h3&gt;

&lt;p&gt;通信速度の設定を行います。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/I2CBRG.jpg&quot; alt=&quot;I2CBRG&quot;&gt;&lt;/p&gt;

&lt;p&gt;400kHzバスで動作している場合、I2Cの仕様上スルーレート制御が必要となります。&lt;/p&gt;

&lt;p&gt;I2CCON&lt;9&gt;がクリアされると、スルーレート制御はアクティブになります。&lt;/p&gt;

&lt;p&gt;(注) その他のバス速度では、スルーレート制御は不要でDISSLWを設定する必要があります&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id=&quot;toc_14&quot;&gt;I2C入出力設定に関する注意点&lt;/h2&gt;

&lt;p&gt;バスオペレーションに使用されるクロック(SCL)ピンとデータ(SDA)ピンはモジュールソフトウェアによってピンのポート入出力を制御しなくても、モジュールがポートの状態と方向をオーバーライドします。&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id=&quot;toc_15&quot;&gt;電圧差に関する注意点&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;dsPIC30F3014 -&amp;gt; 5V駆動
IMU3000      -&amp;gt; 3.3V駆動
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;駆動電圧が異なるため&lt;a href=&quot;http://akizukidenshi.com/catalog/g/gM-05452&quot; title=&quot;PCA9306&quot;&gt;I2Cバス用双方向電圧レベル変換モジュール&lt;/a&gt;を使いましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/LevelConv.jpg&quot; alt=&quot;Level&quot;&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;以上でI2Cの基礎に関する解説を終了します。&lt;/p&gt;

&lt;p&gt;次回は実際にジャイロセンサを動かすサンプルプログラムを紹介する予定です。&lt;/p&gt;
</description>
                <link>http://DaikiMaekawa.github.io/sppboard/2013/08/30/GyroSensor</link>
                <guid>http://DaikiMaekawa.github.io/sppboard/2013/08/30/GyroSensor</guid>
                <pubDate>2013-08-30T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>サーボモータの制御方法</title>
                <description>&lt;hr&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;開発環境&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;基盤　　　　: SPPBoard(dsPIC30F3014使用)
コンパイラ　: C30
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;今回はSPPBoardを用いてサーボモータ(S3003)を制御する方法を解説します。&lt;/p&gt;

&lt;p&gt;S3003はRCサーボなので角度指定にはPWM制御を必要とします。&lt;/p&gt;

&lt;p&gt;つまり、dsPIC入門講座02で解説したOutPutCompare(OC)モジュールを使えばよいのです。&lt;/p&gt;

&lt;p&gt;しかし、SPPBoardに採用したdsPIC30F3014にはOC端子が二つしかありません。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OC端子&lt;/strong&gt;  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/OC_pin.jpg&quot; alt=&quot;OC&quot;&gt;&lt;/p&gt;

&lt;p&gt;車輪ロボット等を駆動させることを考えると最低二つのモータをそれぞれOC端子に割り当てることになりそうです。&lt;/p&gt;

&lt;p&gt;その状態でサーボモータも同時に制御したい場合にはどうすればよいでしょうか?&lt;/p&gt;

&lt;p&gt;ここでは、I/Oピンとタイマを組み合わせてPWM信号を生成することで解決する手法について解説します。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用する端子&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Servo_pin.jpg&quot; alt=&quot;FutabaServo&quot;&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id=&quot;toc_2&quot;&gt;サーボモータの仕様書から必要な情報を読み取ろう&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;サーボのスペック表&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Servo_spec.jpg&quot; alt=&quot;FutabaServo&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.es.co.th/schemetic/pdf/et-servo-s3003.pdf&quot; title=&quot;S3003&quot;&gt;仕様書を入手&lt;/a&gt; &lt;/p&gt;

&lt;h3 id=&quot;toc_3&quot;&gt;タイマの割り込み周期&lt;/h3&gt;

&lt;p&gt;S3003のパルス幅は0.5 ~ 2.3msです。&lt;/p&gt;

&lt;p&gt;よって1.8msの間で0deg ~ 180deg動くことがわかります。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;(2.3 - 0.5) / 180 = 0.01ms で1deg動く
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;きりが良いので、0.01msをタイマの割り込み周期にします。&lt;/p&gt;

&lt;p&gt;(注) S3003には180deg以上回転するので実際のパルス幅で測定すると0.55 ~ 2.35ms付近がちょうど0deg ~ 180degの範囲になっていました。&lt;/p&gt;

&lt;h3 id=&quot;toc_4&quot;&gt;角度制御用の信号&lt;/h3&gt;

&lt;p&gt;認識する周期幅が6 ~ 25msの範囲なので20msくらいの周期幅でHigh, Lowを切り替えます。&lt;/p&gt;

&lt;p&gt;タイマの割り込み周期が0.01msなので2000カウントで20msとなります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/FutabaServo.jpg&quot; alt=&quot;FutabaServo&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;60degに制御する場合&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;0.01ms x 60 = 0.6ms
0.55msで0degなので
0.6ms + 0.55ms = 1.15ms
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;タイマは0.01ms毎の割り込みなので&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;High: 115カウント
Low : 1885カウント
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;とする周期をサーボモータに送ることで60degに制御することができます。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;0degに制御する場合&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;High: 55カウント
Low : 1945カウント
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;180degに制御する場合&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;High: 255カウント
Low : 1745カウント
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;タイマの割り込み周期を0.01msにしたのは1deg動かすために変化させるHighのカウント数を1にするためです。&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id=&quot;toc_5&quot;&gt;サーボモータを動かしてみよう&lt;/h2&gt;

&lt;h3 id=&quot;toc_6&quot;&gt;角度指定用の関数&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;void servo(int angle){
    angle += 145; //90 + 55
    ServoTargetValue = angle
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;angle += 145&lt;/strong&gt;  &lt;/p&gt;

&lt;p&gt;角度の座標系を0 ~ 180degから、中心を0degとした-90 ~ 90degに変更&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;ServoTargetValue&lt;/strong&gt;  &lt;/p&gt;

&lt;p&gt;タイマ1の方でHigh側のカウント上限に使用するグローバル変数&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;toc_7&quot;&gt;初期化関数&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;void ServoInitFunc(void){
    servo(0);
    ConfigIntTimer1(T1_INT_PRIOR_1 &amp;amp; T1_INT_ON);
    OpenTimer1(T1_ON &amp;amp; T1_GATE_OFF &amp;amp; T1_PS_1_1 &amp;amp; T1_SYNC_EXT_OFF &amp;amp; T1_SOURCE_INT, 200-1);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;OpenTimer1(...)&lt;/strong&gt;  &lt;/p&gt;

&lt;p&gt;4/80MHz x 1 x 200 = 0.01msec&lt;/p&gt;

&lt;p&gt;タイマの割り込み周期を0.01msecに設定&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;toc_8&quot;&gt;タイマ関数&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;void _ISR _T1Interrupt(void){
    IFS0bits.T1IF = 0;
    TimeCount++;

    if(TimeCount &amp;lt; ServoTargetValue){
        SERVO = 1;
    }else if(TimeCount &amp;lt;= 2000){
        TimeCount = 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;サーボモータの信号端子にPWM信号を出力します。&lt;/p&gt;

&lt;p&gt;タイマ資源が余っているとき限定ですがこの方法を使用することでどのI/OピンからでもPWM信号を出力できますので試してみてください。&lt;/p&gt;

&lt;p&gt;以上でタイマを使ったサーボモータの制御についての解説を終わります。&lt;/p&gt;
</description>
                <link>http://DaikiMaekawa.github.io/sppboard/2013/08/26/ServoMotor</link>
                <guid>http://DaikiMaekawa.github.io/sppboard/2013/08/26/ServoMotor</guid>
                <pubDate>2013-08-26T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>RoombaのROSドライバをソースからビルドして使ってみる</title>
                <description>&lt;hr&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;開発環境&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;OS     : Ubuntu12.04  
ROS ver: Groovy  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;RoombaをROSのコマンドで動かす&lt;/h2&gt;

&lt;p&gt;ROSを使ってRoombaを動かすために必要そうな情報を収集しているとroomba_500_seriesという便利そうなパッケージを発見しました。&lt;/p&gt;

&lt;p&gt;しかし、サポートされているバージョンがfuerteまでなのでgroovyはソースからビルドするしかなさそうです。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;mkdir ~/ros_ws
cd ~/ros_ws
git clone https://github.com/Arkapravo/roomba_500_ROS_drivers
export ROS_PACKAGE_PATH=$ROS_PACKAGE_PATH:~/ros_ws &amp;gt;&amp;gt; ~/.bashrc
source ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(注) すでにワークスペースがある場合はそこにソースを置いてください。&lt;/p&gt;

&lt;p&gt;当然、catkinへの対応はまだなのでrosmakeでビルドしましょう。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;rosmake roomba_robot 
rosmake serial_communication 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;PCとRoombaをシリアルケーブルでつないだ後にポートを確認すると&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;dmesg | grep tty
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下の様に表示されます。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[35675.368847] usb 1-1.2: FTDI USB Serial Device converter now attached to ttyUSB0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;/dev/ttyUSB0へのアクセス権を取得します。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;sudo chmod 777 /dev/ttyUSB0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;準備が整ったのでノードを起動&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;rosrun roomba_500_series roomba500_light_node
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下のログが表示されれば成功です。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[ INFO] [1377530011.590896574]: Roomba for ROS 2.01
[ INFO] [1377530011.869933041]: Connected to Roomba.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;geometry_msgs/Twistを発行してRoombaを旋回させます。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;rostopic pub -1 cmd_vel geometry_msgs/Twist &amp;#39;[0, 0, 0]&amp;#39; &amp;#39;[0, 0, 0.1]&amp;#39; &amp;amp;&amp;amp; rostopic pub -1 cmd_vel geometry_msgs/Twist &amp;#39;[0, 0, 0]&amp;#39; &amp;#39;[0, 0, 0]&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上でRoombaをコマンドで動かすための解説を終わります。&lt;/p&gt;
</description>
                <link>http://DaikiMaekawa.github.io/ros/2013/08/25/RoombaTutorial</link>
                <guid>http://DaikiMaekawa.github.io/ros/2013/08/25/RoombaTutorial</guid>
                <pubDate>2013-08-25T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>DCモータのPWM制御</title>
                <description>&lt;hr&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;開発環境&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;基盤　　　　: SPPBoard(dsPIC30F3014使用)
コンパイラ　: C30
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;PWMの入門としてDCモータを制御するためのサンプルプログラムをSPPBoardで作成しました。&lt;/p&gt;

&lt;p&gt;ロボット製作ではPWMを扱う機会がとても多いと思います。&lt;/p&gt;

&lt;p&gt;ここでは、ロボット製作の初心者を対象にPWMの概念から丁寧に解説していきたいと思います。&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id=&quot;toc_2&quot;&gt;サンプルプログラムの概要説明&lt;/h2&gt;

&lt;p&gt;OutPutCompareモジュールを使用し、モータの速度制御を行うプログラムです。&lt;/p&gt;

&lt;p&gt;速度変化はデューティ比を100%, 75%, 50% ,25%, 0%と順番に変化させる。&lt;/p&gt;

&lt;p&gt;その際に一定周期で正回転、逆回転を切り替えます。&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id=&quot;toc_3&quot;&gt;OutPutCompareモジュールとは&lt;/h2&gt;

&lt;h3 id=&quot;toc_4&quot;&gt;概念&lt;/h3&gt;

&lt;p&gt;OutPutCompareモジュールを簡単に言い表すなら高速でON/OFFを繰り返すことができる機能です。&lt;/p&gt;

&lt;p&gt;一定時間内におけるON/OFFの比率(デューティ比)を調整することにより速度を制御することができます。&lt;/p&gt;

&lt;h3 id=&quot;toc_5&quot;&gt;動作&lt;/h3&gt;

&lt;p&gt;ON/OFFの周期はタイマに依存します。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;タイマによるカウントを100msecに設定し、デューティ比が50%の場合&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/PWM01.jpg&quot; alt=&quot;Signal&quot;&gt;&lt;/p&gt;

&lt;p&gt;カウント周期はそのままでデューティ比だけを変更した場合を考えてみると以下の用になります。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;デューティ比25%&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/PWM02.jpg&quot; alt=&quot;Signal&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;デューティ比100%&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/PWM03.jpg&quot; alt=&quot;Signal&quot;&gt;&lt;/p&gt;

&lt;p&gt;このようにデューティ比を変化させることで速度を制御することができます。&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id=&quot;toc_6&quot;&gt;制御に必要な回路の知識&lt;/h2&gt;

&lt;h3 id=&quot;toc_7&quot;&gt;ロジック回路の使用&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/NAND01.jpg&quot; alt=&quot;Signal&quot;&gt;&lt;/p&gt;

&lt;p&gt;SPPBoardではOutPutCompareモジュールの出力に74HCT132Eを組み合わせています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/NAND02.jpg&quot; alt=&quot;Signal&quot;&gt;&lt;/p&gt;

&lt;p&gt;1Aと2AがPICのOC2(D1)ピンを共有している点に注目してください。&lt;/p&gt;

&lt;p&gt;OC2とはOutPutCompare2の略です。&lt;/p&gt;

&lt;p&gt;つまり、OC2からPWM出力を行っている際に74HCT132Eの1Aと2Aが同時に
1 -&amp;gt; 0を一定周期で繰り返すということがわかります。 &lt;/p&gt;

&lt;h3 id=&quot;toc_8&quot;&gt;モータドライバの使用&lt;/h3&gt;

&lt;p&gt;次はモータドライバについて解説します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/MotorDriver01.jpg&quot; alt=&quot;MotorDriver&quot;&gt;&lt;/p&gt;

&lt;p&gt;SPPBoardにはTA7291Pを使っています。&lt;/p&gt;

&lt;p&gt;念のためモータドライバの原理についても解説しましょう。&lt;/p&gt;

&lt;h3 id=&quot;toc_9&quot;&gt;Hブリッジ回路&lt;/h3&gt;

&lt;p&gt;Mはモータを表しています。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ストップ&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/MotorDriver02.png&quot; alt=&quot;MotorDriver&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;モータが回転&lt;/strong&gt;
&lt;img src=&quot;/images/MotorDriver03.png&quot; alt=&quot;MotorDriver&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;先ほどと逆回転&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/MotorDriver04.png&quot; alt=&quot;MotorDriver&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ブレーキ&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/MotorDriver05.png&quot; alt=&quot;MotorDriver&quot;&gt;&lt;/p&gt;

&lt;p&gt;(注)すべてのモータドライバが上記の仕様とは限りません。&lt;/p&gt;

&lt;p&gt;種類によってはブレーキモードが存在しないもの等もあります。&lt;/p&gt;

&lt;p&gt;今回使用するTA7291Pはどうなっているのか仕様書から確認してみましょう。&lt;/p&gt;

&lt;h3 id=&quot;toc_10&quot;&gt;モータドライバの仕様書から読み取る&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;端子の確認&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/MotorDriver_spec01.jpg&quot; alt=&quot;pin&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ファンクションの確認&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/MotorDriver_spec02.jpg&quot; alt=&quot;func&quot;&gt;&lt;/p&gt;

&lt;p&gt;ファンクションを見ればモータドライバにどのような入力が必要なのかが一目でわかります。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;ブレーキモード
 - IN1 5V
 - IN2 5V

正回転
 - IN1 5V
 - IN2 0V

逆回転
 - IN1 0V
 - IN2 5V
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;toc_11&quot;&gt;モータドライバへの接続&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;モータドライバとロジック回路の接続&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/MotorDriver_spec03.jpg&quot; alt=&quot;connect&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;TA7291P          74HCT132E
 IN1     &amp;lt;--&amp;gt;     2Y
 IN2     &amp;lt;--&amp;gt;     1Y
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;モータドライバとロジック回路の関係性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;(注) ()はそれ以外の組み合わせが存在する事を示しています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/MotorDriver_spec04.jpg&quot; alt=&quot;rel&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;dsPICとロジック回路の関係性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前述したとおり、OutPutCompare2を使用した際、1Aと2Aが1 -&amp;gt; 0を繰り返します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/MotorDriver_spec05.jpg&quot; alt=&quot;rel2&quot;&gt;&lt;/p&gt;

&lt;p&gt;このことからモータの回転を制御するために調節すればいいのは1Bと2Bだと分かります。&lt;/p&gt;

&lt;p&gt;以上で回路に関する説明は終わりです。&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id=&quot;toc_12&quot;&gt;サンプルプログラム&lt;/h2&gt;

&lt;p&gt;まずはピンの別名を定義&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;#define PWM_1A_AND_2A LATDbits.LATD1
#define PWM_1B LATFbits.LATF0
#define PWM_2B LATFbits.LATF1

enum MotionType{NORMAL, REVERSE};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;今回はOutPutCompare2を使用しますのでPWM_1A_AND_2Aを直接変更することはありません。&lt;/p&gt;

&lt;p&gt;コンフィギュレーション設定はいつもどおりなので省略&lt;/p&gt;

&lt;h3 id=&quot;toc_13&quot;&gt;main文の中&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;short MotionType
int i;
float Duty_set[] = {1.0, 0.75, 0.5, 0.25, 0.0};

TRISD = 0x0000;
TRISF = 0x0000;

OpenOC2(OC_IDLE_CON &amp;amp; OC_TIMER2_SRC &amp;amp; OC_PWM_FAULT_PIN_DISABLE, 0, 0);
OpenTimer2(T2_ON &amp;amp; T2_GATE_OFF &amp;amp; T2_PS_1_64 &amp;amp; T2_SOURCE_INT, 3125-1);

MotionType = NORMAL;
PWM_1B = 1;
PWM_2B = 0;

while(1){
    for(i=0; i&amp;lt;5; i++){
        SetDCOC2PWM(3125*Duty_set[i]);
        wait_msec(1000);
    }

    if(MotionType == NORMAL){
        ///逆回転にセット
        PWM_1B = 0;
        PWM_2B = 1;
        MotionType = REVERSE;
    }else{
        ///正回転にセット
        PWM_1B = 1;
        PWM_2B = 0;
        MotionType = NORMAL;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;OpenOC2(...)&lt;/strong&gt;&lt;br&gt;
OC_IDLE_CON              : アイドルループ内動作継続&lt;br&gt;
OC_TIMER2_SRC            : タイマ2を選択&lt;br&gt;
OC_PWM_FAULT_PIN_DISABLE : 出力モードをPWMに設定&lt;br&gt;
第2引数                  : OCxRSレジスタに設定する値&lt;br&gt;
第3引数                  : OCxRレジスタに設定する値&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;toc_14&quot;&gt;OpenOC関数の詳しい解説&lt;/h3&gt;

&lt;p&gt;OutPutCompareモジュールはタイマ2かタイマ3のカウンタとOCxRレジスタかOCxRSレジスタの値を常時比較していて、一致したとき、何らかの出力をOCx端子にするというものです。&lt;/p&gt;

&lt;p&gt;OCx出力とはOutPutCompare出力の略で今回ではdsPICのOC2端子からの出力されるものを指します。&lt;/p&gt;

&lt;p&gt;1) 今回はOCxRレジスタ、OCxRSレジスタともに0に設定しました。&lt;/p&gt;

&lt;p&gt;2) そしてカウンタはタイマ2を使用します。&lt;/p&gt;

&lt;p&gt;3) PWMモードを指定しているので、OCxRレジスタが比較対象(今回OCxRSレジスタの値は意味なし)となり、一致によりOCxレジスタはLowに制御されます。
逆にタイマが0クリアされるときは、OCxレジスタがHighに制御されます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;OpenTimer2(...)&lt;/strong&gt;&lt;br&gt;
4/80MHzx64x3125=10msec&lt;/p&gt;

&lt;p&gt;OC2出力周期(ON/OFF周期)が0.01秒に決定&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;toc_15&quot;&gt;モータの回転方向とブレーキ制御&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;PWM_1B = 1
PWM_2B = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;この時モータは正回転する&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Motor_cw.jpg&quot; alt=&quot;Motor_cw&quot;&gt;&lt;/p&gt;

&lt;p&gt;一応ファンクションを確認&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Motor_cw_func.jpg&quot; alt=&quot;Motor_cw_func&quot;&gt;&lt;/p&gt;

&lt;p&gt;ではOC2出力が0の時モータは、ちゃんと停止しているのでしょうか。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Motor_stop.jpg&quot; alt=&quot;Motor_stop&quot;&gt;&lt;/p&gt;

&lt;p&gt;モータがブレーキモードになっていることがわかると思います。&lt;/p&gt;

&lt;p&gt;一応ファンクションを確認&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Motor_stop_func.jpg&quot; alt=&quot;Motor_stop_func&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;PWM_1B = 0
PWM_2B = 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;この時モータは逆回転する。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Motor_ccw.jpg&quot; alt=&quot;Motor_ccw&quot;&gt;&lt;/p&gt;

&lt;p&gt;一応ファンクションを確認&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Motor_ccw_func.jpg&quot; alt=&quot;Motor_ccw_func&quot;&gt;&lt;/p&gt;

&lt;h3 id=&quot;toc_16&quot;&gt;モータの速度制御&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;SetDCOC2PWM(3125 * Duty_set[i])&lt;/strong&gt;&lt;br&gt;
デューティ比を100% ~ 0%まで段階的に変更する&lt;/p&gt;

&lt;p&gt;これによりモータがブレーキモードになる比率を変更でき、
結果として速度を変化させることができます。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;初心者向けの解説なので冗長な説明が多かったと思いますが&lt;/p&gt;

&lt;p&gt;以上でDCモータの制御に関する解説を終わります。&lt;/p&gt;
</description>
                <link>http://DaikiMaekawa.github.io/sppboard/2013/08/19/DCMotor</link>
                <guid>http://DaikiMaekawa.github.io/sppboard/2013/08/19/DCMotor</guid>
                <pubDate>2013-08-19T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>LCDの制御方法</title>
                <description>&lt;hr&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;開発環境&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;基盤　　　　: SPPBoard(dsPIC30F3014使用)
コンパイラ　: C30
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;組み込みプログラムの入門として&lt;/p&gt;

&lt;p&gt;1 ~ 9までの数字を0.1秒毎にカウントアップしてLCDの1マス目に表示するプログラムを作成しました。&lt;/p&gt;

&lt;p&gt;LCDは&lt;a href=&quot;http://akizukidenshi.com/catalog/g/gP-01797/&quot; title=&quot;SD1602HUOB&quot;&gt;SD1602HUOB&lt;/a&gt;を使用します。&lt;/p&gt;

&lt;p&gt;それでは、仕様書の読み方から解説していきたいと思います。&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id=&quot;toc_2&quot;&gt;LCDの仕様書から必要な情報を読み取ろう&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;基礎知識&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;R/S端子 
 - Low : コマンドと認識
 - High: 文字データと認識

R/W端子
 - Low : Writeモード
 - High: Readモード

E端子
 - Low -&amp;gt; Highに変化で命令を回収
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;今回はR/WはGNDに落としているため常にWriteモードです。&lt;/p&gt;

&lt;p&gt;E端子は意図的な命令であることと信号を送るタイミングを知らせるために使います。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;用意されたコマンド&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;Clear Display       0000 0001
Cursor At Home      0000 0010
Entry Mode Set      0000 0100
Display ON/OFF      0000 1000
Cursor/DisplayShift 0001 0000
Function Set        0010 0000
CGRAW AddressSet    0100 0000
DDRAW AddressSet    1000 0000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;どの位置に1を立てるかでどのコマンドかが判別されます。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LCDの初期化手順&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;電源ON
15ms以上待つ
8ビットモードに設定
4.1ms以上待つ
8ビットモードに設定
100us以上待つ
8ビットモードに設定
4ビットモードに設定
ファンクション設定
ディスプレイOFF
ディスプレイON
エントリーモード
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h2 id=&quot;toc_3&quot;&gt;LCDの制御関数を作ろう&lt;/h2&gt;

&lt;p&gt;まず、ピンの名前をわかりやすく定義しましょう。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;#define LCD_RS LATBbits.LATB5
#define LCD_E  LATBbits.LATB4
#define LCD_D4 LATBbits.LATB9
#define LCD_D5 LATBbits.LATB10
#define LCD_D6 LATBbits.LATB11
#define LCD_D7 LATBbits.LATB12
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;8ビットモード用指令関数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;void lcd_out8(unsigned char dat){
    LCD_RS = 0;
    LCD_E  = 1;
    LCD_D4 = (dat &amp;amp; 0x01);
    dat = dat &amp;gt;&amp;gt; 1;
    LCD_D5 = (dat &amp;amp; 0x01);
    dat = dat &amp;gt;&amp;gt; 1;
    LCD_D6 = (dat &amp;amp; 0x01);
    dat = dat &amp;gt;&amp;gt; 1;
    LCD_D7 = (dat &amp;amp; 0x01);

    wait_usec(50);
    LCD_E = 0;
    wait_usec(50);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;LCD_RS = 0&lt;/strong&gt;&lt;br&gt;
LCDにコマンドを送信&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;LCD_E = 1&lt;/strong&gt;&lt;br&gt;
コマンドを回収(450nsecの時間が必要)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;LCD_D[4-7] = (dat &amp;amp; 0x01)&lt;/strong&gt;&lt;br&gt;
LCDの上位4本に指令を送信&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;wait_usec(50)&lt;/strong&gt;&lt;br&gt;
上記の命令を回収&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;LCD_E = 0&lt;/strong&gt;&lt;br&gt;
E端子をLowへ&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;上位ピンに一つずつ送る理由&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/SPPBoard.BMP&quot; alt=&quot;SPPBoard&quot;&gt;&lt;/p&gt;

&lt;p&gt;LCDの上位4ピンは9, 10, 11, 12に接続されています。&lt;/p&gt;

&lt;p&gt;char型は8ビットなのでまとめてLATBで出力に変更できないからです。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4ビットモード用指令関数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;void lcd_out4(int rs, unsigned char dat){
    unsigned char bk = dat;

    LCD_RS = rs;
    LCD_E  = 1;

    bk = bk &amp;gt;&amp;gt; 4;
    LCD_D4 = (bk &amp;amp; 0x01);
    bk = bk &amp;gt;&amp;gt; 1;
    LCD_D5 = (bk &amp;amp; 0x01);
    bk = bk &amp;gt;&amp;gt; 1;
    LCD_D6 = (bk &amp;amp; 0x01);
    bk = bk &amp;gt;&amp;gt; 1;
    LCD_D7 = (bk &amp;amp; 0x01);

    wait_usec(50);
    LCD_E = 0;
    wait_usec(50);

    LCD_E = 1;

    LCD_D4 = (dat &amp;amp; 0x01);
    dat = dat &amp;gt;&amp;gt; 1;
    LCD_D5 = (dat &amp;amp; 0x01);
    dat = dat &amp;gt;&amp;gt; 1;
    LCD_D6 = (dat &amp;amp; 0x01);
    dat = dat &amp;gt;&amp;gt; 1;
    LCD_D7 = (dat &amp;amp; 0x01);

    wait_usec(50);
    LCD_E = 0;
    wait_usec(50);
    LCD_RS = 0;

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;引数rsが0の時コマンド、1の時文字データとして扱います。&lt;/p&gt;

&lt;p&gt;LCDへは上位4ビット、下位4ビットの順に送信します。&lt;/p&gt;

&lt;p&gt;例として引数datに0010 1000が渡されたとします。&lt;/p&gt;

&lt;p&gt;順番だけ見ればLCDは0010 0001と認識しそうですがLCD_D7が12ビット目なのを思い出すと&lt;/p&gt;

&lt;p&gt;それぞれ反転して0010 1000となることがわかるでしょう。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LCD初期化関数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;void lcd_format(void){

    wait_msec(20);
    lcd_out8(0x23);
    wait_msec(10);
    lcd_out8(0x23);
    lcd_out8(0x22);
    lcd_out4(0, 0x28);
    lcd_out4(0, 0x0E);
    lcd_out4(0, 0x06);
    lcd_out4(0, 0x02);

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;仕様書よりも長めにwaitを入れています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;lcd_out8(0x23)&lt;/strong&gt;&lt;br&gt;
Function Set コマンド&lt;br&gt;
0010 0011 -&amp;gt; (認識)0011 0000&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;lcd_out8(0x22)&lt;/strong&gt;&lt;br&gt;
Function Set コマンド&lt;br&gt;
0010 0010 -&amp;gt; (認識)0010 0000&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;lcd_out4(0, 0x28)&lt;/strong&gt;&lt;br&gt;
Function Set コマンド&lt;br&gt;
0010 1000&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;lcd_out4(0, 0x0E)&lt;/strong&gt;&lt;br&gt;
Display ON/OFF コマンド&lt;br&gt;
0000 1110&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;lcd_out4(0, 0x06)&lt;/strong&gt;&lt;br&gt;
Entry ModeSet コマンド&lt;br&gt;
0000 0110&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;lcd_out4(0, 0x02)&lt;/strong&gt;&lt;br&gt;
Cursor At Home コマンド&lt;br&gt;
0000 0010&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;1文字表示関数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;void lcd_data(unsigned char asci){
    lcd_out4(1, asci);
    wait_usec(50);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;文字列表示関数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;void lcd_puts(unsigned char *str){
    while(*str != 0x00){
        lcd_out4(1, *str);
        str++;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;数字表示関数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;void lcd_convert(unsigned int number){
    lcd_data(&amp;#39;0&amp;#39; + number);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;画面消去関数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;void lcd_clear(void){
    lcd_out4(0, 0x01);
    wait_usec(1650);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h2 id=&quot;toc_4&quot;&gt;LCD制御関数を使ってみよう&lt;/h2&gt;

&lt;p&gt;まずはコンフィギュレーション設定をしましょう。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;_FOSC(CSW_FSCM_OFF &amp;amp; XT_PLL8);
_FWDT(WDT_OFF);
_FBORPOR(PBOR_ON &amp;amp; BORV_20 &amp;amp; PWRT_64 &amp;amp; MCLR_EN);
_FGS(CODE_PROT_OFF);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;_FOSC(CSW_FSCM_OFF &amp;amp; XT_PLL8)&lt;/strong&gt;&lt;br&gt;
クロック停止の際の処理を監視せず、内部の別クロック源への切り替えもしないので&lt;br&gt;
CSW(クロック切り替え)とFSCM(クロックのエラー検出)をOFFに設定&lt;br&gt;
8x10MHz(外部発振器) = 80MHz(クロック周波数)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;_FWDT(WDT_OFF)&lt;/strong&gt;&lt;br&gt;
特にシステムの監視を行わないためウォッチドックタイマを無効&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;_FBORPOR(PBOR_ON &amp;amp; BORV_20 &amp;amp; PWRT_64 &amp;amp; MCLR_EN)&lt;/strong&gt;&lt;br&gt;
電源ON直後に動作をリセット&lt;br&gt;
電源OFF直後に動作停止&lt;br&gt;
電源OFFを検出する電圧 -&amp;gt; 2.0V&lt;br&gt;
電源ON直後のリセットパルス幅 -&amp;gt; 64msec&lt;br&gt;
MCLRピンを有効&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;_FGS(CODE_PROT_OFF)&lt;/strong&gt;&lt;br&gt;
コードプロテクト -&amp;gt; 読み出し、書き込みともにOFF&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;main文の中&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;unsigned char msgA[] = &amp;quot;start&amp;quot;;
LATB = 0x0;
TRISB = 0x00;

lcd_format();

lcd_puts(msgA);
wait_msec(1000);

ConfigIntTimer1(T1_INT_PRIOR_3 &amp;amp; T1_INT_ON);
OpenTimer1(T1_ON &amp;amp; T1_GATE_OFF &amp;amp; T1_PS_1_64 &amp;amp; 
           T1_SYNC_EXT_OFF &amp;amp; T1_SOURCE_INT, 31250-1);

while(1);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;ConfigIntTimer1(T1_INT_PRIOR_3 &amp;amp; T1_INT_ON)&lt;/strong&gt;&lt;br&gt;
優先度3 &amp;amp; 割り込み許可&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;OpenTimer1(...)&lt;/strong&gt;&lt;br&gt;
タイマ周期=(4/クロック周波数)x(プリスケーラ分周比)x(PR1設定-1)
100msec   = 4/80MHz          x 64                 x 31250&lt;/p&gt;

&lt;p&gt;T1_ON           : タイマ1を有効&lt;br&gt;
T1_GATE_OFF     : ゲートタイマモードOFF(外部信号の時間幅の計測をしない)&lt;br&gt;
T1_PS_1_64      : プリスケーラ分周比を64に設定&lt;br&gt;
T1_SYNC_EXT_OFF : タイマ非同期&lt;br&gt;
T1_SOURCE_INT   : 内部クロックを使用&lt;br&gt;
31250-1         : PR1設定&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;タイマ1の定義&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;void _ISR _T1Interrupt(void){
    static unsigned int TimeCount1 = 0;
    IFS0bits.T1IF = 0;

    TimeCount1++;

    if(TimeCount1 &amp;lt;= 9){
        lcd_clear();
        lcd_convert(TimeCount1);
    }else{
        TimeCount1 = 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;IFS0bits.T1IF = 0&lt;/strong&gt;&lt;br&gt;
割り込みサブルーチンの構文では割り込みフラグをクリアできないため&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;以上で100msec毎に1~9までの範囲でカウントアップするプログラムは完成です。&lt;/p&gt;
</description>
                <link>http://DaikiMaekawa.github.io/sppboard/2013/08/18/LCD</link>
                <guid>http://DaikiMaekawa.github.io/sppboard/2013/08/18/LCD</guid>
                <pubDate>2013-08-18T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>教育用マイコンボードの開発</title>
                <description>&lt;p&gt;千葉工業大学の中島研究室によって教育用マイコンボードであるSPPBoardが開発されました。&lt;/p&gt;

&lt;p&gt;SPPは(独)科学技術振興機構のサイエンスパートナーシッププロジェクトの略で千葉県全ての工業高校と連携し、SPPBoardを用いたロボット活用教育講座が開催されました。&lt;/p&gt;

&lt;p&gt;中核であるマイコンはdsPIC30F3014を採用し、開発ツールとしてMPLABとC30コンパイラを使用します。&lt;/p&gt;

&lt;p&gt;提供されるのはボードだけで制御用のライブラリはこれから開発する予定です。&lt;/p&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;回路図&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/images/SPPBoard.BMP&quot; alt=&quot;SPPBoard&quot;&gt;&lt;/p&gt;

&lt;p&gt;このブログではサンプルプログラムを作成、解説しながらこの開発ボードを宣伝していこうと思います。&lt;/p&gt;
</description>
                <link>http://DaikiMaekawa.github.io/sppboard/2011/05/10/SPPBoard</link>
                <guid>http://DaikiMaekawa.github.io/sppboard/2011/05/10/SPPBoard</guid>
                <pubDate>2011-05-10T00:00:00+09:00</pubDate>
        </item>


</channel>
</rss>
